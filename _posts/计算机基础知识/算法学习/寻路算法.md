## 寻路算法总结

在图算法中，寻路算法算是及其经典的问题了，如 深度优先搜索（DFS），广度优先搜索（BFS），A* 算法。整体而言他们分为两大类，盲目式和启发式，所谓**盲目式**是在寻路中搜索需要的目标，**启发式**则是知道目标在哪儿。

其中 DFS,BFS 就是经典的图搜索算法，而寻路则需要搭配回溯来实现路径回显。

## DFS 模板
```javascript
const next = x=>x+1;
const prev = x=>x-1;
const keep = x=>x;
const dxy = [
    {row:next,col:keep},
    {row:next,col:keep},
    {row:keep,col:prev},
    {row:prev,col:keep},
    {row:keep,col:next},
];

const id = target => target.join("-");
const valid = ([row,col],maps)=>maps[row][col] !== -1;

// 递归版
function dfs(maps,[row,col] = [0,0],visited = new Set(),fathers = new Map()){
    const maxRows = maps[row].length;
    const maxCols = maps[col].length;
    const curId = id([row,col]);
    if (visited.has(curId)) {
        // 已经访问过了
        return fathers;
    }
    visited.add(curId);

    for (let xy=0;xy<dxy.length;xy++){
        const nextRow = dxy[xy].row(row);
        const nextCol = dxy[xy].col(col);
        let nextCell = [nextRow,nextCol];
        let nextCellId = id([nextRow,nextCol]);
        if (nextRow >= maxRows|| nextCol >= maxCols|| nextRow < 0|| nextCol < 0) continue;
        if (visited.has(nextCellId)) continue;
        if (!valid(nextCell,maps)) continue;
        
        fathers.set(nextCellId,[row,col]);
        dfs(maps,[nextRow,nextCol],visited,fathers);
    }

    return fathers;
}


const maps = [
    [0, 0,0,3 ],
    [-1, -1, 2, 3],
    [0, 1, 2, 3],
    [0, 1, 2, -3],
]
console.log(dfs(maps))

```


## BFS 模板

```javascript
/**
 * 算法目的： BFS 搜索算法，同时建立基于中心 source 的树状信息。
 * 
*/

const next = x=>x+1;
const prev = x=>x-1;
const keep = x=>x;
const dxy = [
    {row:next,col:keep},
    {row:next,col:keep},
    {row:keep,col:prev},
    {row:prev,col:keep},
    {row:keep,col:next},
];

const id = target => target.join("-");
const valid = ([row,col],maps)=>maps[row][col] !== -1;

function bfs(maps,source = [0,0]){
    const queue = [source];
    const visited = new Set();
    const fathers = new Map();
    // 覆写 queue push ，并标记路径 now->father
    function queuePush(point,father){
        fathers.set(id(point),father);
        return queue.push(point);
    }
    
    // S 初始化
    visited.add(id(source));
    const maxRows = maps.length;    
    // E 初始化

    while (queue.length) {
        const cur = queue.shift();
        const [row,col] = cur;
        
        const maxCols = maps[row].length;
        // S 遍历四个方向
        for (let xy=0;xy<dxy.length;xy++){
            const nextRow = dxy[xy].row(row);
            const nextCol = dxy[xy].col(col);
            const tmpPoint = [nextRow,nextCol]
            const tmpPointId = id(tmpPoint);
            if (
                nextRow >= maxRows
                || nextCol >= maxCols
                || nextRow < 0
                || nextCol < 0
            ) continue;
            
            if (visited.has(tmpPointId)) continue;
            visited.add(tmpPointId);

            // check can be go 
            if (!valid(tmpPoint,maps)) continue;
            queuePush(tmpPoint,cur);
        }
        // E 遍历四个方向
    } 
    console.log(fathers)
}

const maps = [
    [0, 0, -1, 3],
    [-1, -1, 2, 3],
    [0, 1, 2, 3],
    [0, 1, 2, -3],
]
console.log(bfs(maps))
```